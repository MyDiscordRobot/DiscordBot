import { URL } from 'node:url';

/**
 * Compare if both arrays are strictly equal
 * @param arr1 The array to compare to
 * @param arr2 The array to compare with
 */
declare function arrayStrictEquals<T extends readonly unknown[]>(arr1: T, arr2: T): boolean;

/**
 * Casts any value to `T`
 *
 * Note that this function is not type-safe, and may cause runtime errors if used incorrectly.
 * Also note that this function is effectively useless in a JavaScript project, it only serves a purpose for TypeScript projects.
 *
 * @param value The value to cast to another type
 * @returns The value but as type `T`
 */
declare function cast<T>(value: unknown): T;

/**
 * Splits up an array into chunks
 * @param array The array to chunk up
 * @param chunkSize The size of each individual chunk
 */
declare function chunk<T>(array: readonly T[], chunkSize: number): T[][];

declare type Primitive = string | number | boolean | bigint | symbol | undefined | null;
declare type Builtin = Primitive | Function | Date | Error | RegExp;
declare type DeepRequired<T> = T extends Builtin ? NonNullable<T> : T extends Map<infer K, infer V> ? Map<DeepRequired<K>, DeepRequired<V>> : T extends ReadonlyMap<infer K, infer V> ? ReadonlyMap<DeepRequired<K>, DeepRequired<V>> : T extends WeakMap<infer K, infer V> ? WeakMap<DeepRequired<K>, DeepRequired<V>> : T extends Set<infer U> ? Set<DeepRequired<U>> : T extends ReadonlySet<infer U> ? ReadonlySet<DeepRequired<U>> : T extends WeakSet<infer U> ? WeakSet<DeepRequired<U>> : T extends Promise<infer U> ? Promise<DeepRequired<U>> : T extends {} ? {
    [K in keyof T]-?: DeepRequired<T[K]>;
} : NonNullable<T>;
declare type RequiredExcept<T, K extends keyof T> = Partial<Pick<T, K>> & Required<Omit<T, K>>;
declare type PartialRequired<T, K extends keyof T> = Partial<Omit<T, K>> & Required<Pick<T, K>>;
declare type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]>;
};
declare type ArgumentTypes<F extends (...args: any[]) => unknown> = F extends (...args: infer A) => any ? A : never;
/**
 * A readonly array of any values.
 * @private
 */
declare type Arr = readonly any[];
/**
 * A generic constructor with parameters
 */
declare type Ctor<A extends Arr = readonly any[], R = any> = new (...args: A) => R;
/**
 * A generic abstract constructor with parameters
 */
declare type AbstractCtor<A extends Arr = readonly any[], R = any> = abstract new (...args: A) => R;
/**
 * A generic constructor without parameters
 */
declare type Constructor<T> = new (...args: any[]) => T;
/**
 * A generic abstract constructor without parameters
 */
declare type AbstractConstructor<T> = abstract new (...args: any[]) => T;
/**
 * Gets the first argument of any given function
 */
declare type FirstArgument<T> = T extends (arg1: infer U, ...args: unknown[]) => unknown ? U : unknown;
/**
 * Gets the second argument of any given function
 */
declare type SecondArgument<T> = T extends (arg1: unknown, arg2: infer U, ...args: unknown[]) => unknown ? U : unknown;
/**
 * ReturnType for a function that can return either a value or a `Promise` with that value
 */
declare type Awaitable<T> = PromiseLike<T> | T;
/**
 * Type union for the full 2 billion dollar mistake in the JavaScript ecosystem
 */
declare type Nullish = null | undefined;
/**
 * Similar to the built in {@link NonNullable}, but properly removes `null` from all keys in the class or interface
 * This does not recurse deeply, for that use {@link DeepRequired}
 */
declare type NonNullableProperties<T = unknown> = {
    [P in keyof T]: NonNullable<T[P]>;
};
/**
 * An object that is non nullable, to bypass TypeScript not easily working with {@link Record}<{@link PropertyKey}, unknown> in various instances.
 */
declare type NonNullObject = {} & object;
/**
 * An object that can have any structure, this is an alternative to {@link NonNullObject} for situations where
 * that leads to unexpected type resolutions.
 *
 * Note that this is still a strictly typed type, it is not simply aliasing `any`
 */
declare type AnyObject<T> = {
    [K in keyof T]: T[K];
};
/**
 * Gets all the keys (as a string union) from a type `T` that match value `V`
 * @example
 * ```typescript
 * interface Sample {
 * 	id: string;
 * 	name: string | null;
 * 	middleName?: string;
 * 	lastName: string;
 * 	hobbies: readonly string[];
 * }
 *
 * type BB = PickByValue<Sample, string>;
 * // Expected:
 * // "id" | "lastName"
 * ```
 */
declare type PickByValue<T, V> = {
    [P in keyof T]: T[P] extends V ? P : never;
}[keyof T] & keyof T;
/**
 * Transforms a `readonly` type to be mutable
 * @example
 * ```typescript
 * interface Sample {
 * 	id: string;
 * 	hobbies: readonly string[];
 * }
 *
 * type BB = Mutable<Sample>;
 * // Expected:
 * // {
 * //    id: string;
 * //    hobbies: string[];
 * // }
 * ```
 */
declare type Mutable<T> = {
    -readonly [P in keyof T]: T[P] extends Array<unknown> | NonNullObject ? Mutable<T[P]> : T[P];
};
/**
 * Transforms every key in an object to be strictly required, essentially removing `undefined` and `null` from the type.
 * @example
 * ```typescript
 * interface Sample {
 * 	id: string;
 * 	name: string | null;
 * 	middleName?: string;
 * }
 *
 * type BB = StrictRequired<Sample>;
 * // Expected:
 * // {
 * //    id: string;
 * //    name: string;
 * //    middleName: string;
 * // }
 * ```
 */
declare type StrictRequired<T> = {
    [P in keyof T]-?: NonNullable<T[P]>;
};
/**
 * Gets a union type of all the keys that are in an array.
 * @example
 * ```typescript
 * const sample = [1, 2, '3', true];
 *
 * type arrayUnion = ArrayElementType<typeof sample>;
 * // Expected: string | number | boolean
 * ```
 */
declare type ArrayElementType<T> = T extends (infer K)[] ? K : T extends readonly (infer RK)[] ? RK : T;

/**
 * Checks whether or not the value class extends the base class.
 * @param value The constructor to be checked against.
 * @param base The base constructor.
 */
declare function classExtends<T extends Ctor>(value: Ctor, base: T): value is T;

/**
 * Wraps text in a markdown codeblock with optionally a language indicator for syntax highlighting
 * @param language The codeblock language
 * @param expression The expression to be wrapped in the codeblock
 */
declare function codeBlock<T>(language: string, expression: T): string;

/**
 * Split a text by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @copyright 2019 Antonio Román
 * @license Apache-2.0
 */
declare function cutText(str: string, length: number): string;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
interface DebounceSettings {
    /**
     * The number of milliseconds to delay.
     * @default 0
     */
    wait?: number;
    /**
     * The maximum time `func` is allowed to be delayed before it's invoked
     * @default null
     */
    maxWait?: number | null;
}
interface DebouncedFunc<FnArgumentsType extends any[], FnReturnType> {
    /**
     * Call the original function, but applying the debounce rules.
     *
     * If the debounced function can be run immediately, this calls it and returns its return
     * value.
     *
     * Otherwise, it returns the return value of the last invocation, or undefined if the debounced
     * function was not invoked yet.
     */
    (...args: FnArgumentsType): FnReturnType | undefined;
    /**
     * Throw away any pending invocation of the debounced function.
     */
    cancel(): void;
    /**
     * If there is a pending invocation of the debounced function, invoke it immediately and return
     * its return value.
     *
     * Otherwise, return the value from the last invocation, or undefined if the debounced function
     * was never invoked.
     */
    flush(): FnReturnType | undefined;
}
/**
 * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since
 * the last time the debounced function was invoked. The debounced function comes with a cancel method to
 * cancel delayed invocations and a flush method to immediately invoke them. Provide an options object to
 * indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent
 * calls to the debounced function return the result of the last func invocation.
 *
 * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only
 * if the the debounced function is invoked more than once during the wait timeout.
 *
 * See David Corbacho’s article for details over the differences between _.debounce and _.throttle.
 *
 * @param func The function to debounce.
 * @param wait The number of milliseconds to delay.
 * @param options The options object.
 * @return Returns the new debounced function.
 */
declare function debounce<FnArgumentsType extends any[], FnReturnType>(func: (...args: FnArgumentsType) => FnReturnType, options?: DebounceSettings): DebouncedFunc<FnArgumentsType, FnReturnType>;

/**
 * Deep clone an object
 * @param source The object to clone
 */
declare function deepClone<T>(source: T): T;

/**
 * Checks whether a value is not `null` nor `undefined`.
 * This can be used in {@link Array.filter} to remove `null` and `undefined` from the array type
 * @param value The value to verify that is neither `null` nor `undefined`
 * @returns A boolean that is `true` if the value is neither `null` nor `undefined`, false otherwise.
 * @example
 * ```typescript
 * // TypeScript Type: (string | undefined | null)[]
 * const someArray = ['one', 'two', undefined, null, 'five'];
 *
 * // TypeScript Type: string[]
 * const filteredArray = someArray.filter(filterNullAndUndefined);
 * // Result: ['one', 'two', 'five']
 * ```
 */
declare function filterNullAndUndefined<TValue>(value: TValue | Nullish): value is TValue;

/**
 * Checks whether a value is not `null` nor `undefined` nor `''` (empty string).
 * This can be used in {@link Array.filter} to remove `null`, `undefined` from the array type
 * @param value The value to verify that is neither `null`, `undefined` nor `''` (empty string)
 * @returns A boolean that is `true` if the value is neither `null`, `undefined` nor `''` (empty string), false otherwise.
 * @example
 * ```typescript
 * // TypeScript Type: (string | undefined | null)[]
 * const someArray = ['one', 'two', undefined, null, ''];
 *
 * // TypeScript Type: string[]
 * const filteredArray = someArray.filter(filterNullAndUndefinedAndEmpty);
 * // Result: ['one', 'two']
 * ```
 */
declare function filterNullAndUndefinedAndEmpty<TValue>(value: TValue | Nullish | ''): value is TValue;

/**
 * Checks whether a value is not `null` nor `undefined` nor `0`.
 * This can be used in {@link Array.filter} to remove `null`, `undefined` from the array type
 * @param value The value to verify that is neither `null`, `undefined` nor `0`
 * @returns A boolean that is `true` if the value is neither `null`, `undefined` nor `0`, false otherwise.
 * @example
 * ```typescript
 * // TypeScript Type: (string | number | undefined | null)[]
 * const someArray = ['one', 'two', undefined, null, 0, 1];
 *
 * // TypeScript Type: (string | number)[]
 * const filteredArray = someArray.filter(filterNullAndUndefinedAndZero);
 * // Result: ['one', 'two', 1]
 * ```
 */
declare function filterNullAndUndefinedAndZero<TValue>(value: TValue | Nullish | 0): value is TValue;

/**
 * Flattens an object to a list of its keys, traversing deeply into nested objects and arrays of objects.
 *
 * @note By default Nested array values are flattened to `arrayKey.${index}.subKey`.
 * This can be changed to `arrayKey[${index}].subKey` by setting `options.arrayKeysIndexStyle` to `'braces-with-dot'`.
 * Or it can also be changed to `arrayKey[${index}]subKey` by setting `options.arrayKeysIndexStyle` to `'braces'`.
 *
 * @param obj The object of which to deeply retrieve its keys
 * @param options The options with which to customize the output of this function
 * @returns An array of strings holding the keys of the object
 */
declare function getDeepObjectKeys<T>(obj: AnyObject<T>, options?: GetDeepObjectKeysOptions): string[];
/**
 * The options for {@link getDeepObjectKeys}
 */
interface GetDeepObjectKeysOptions {
    /**
     * Whether to use `.${index}.` (`'dotted'`), `[${index}].`, (`'braces-with-dot'`) or `[${index}]` (`'braces'`) to separate array keys
     * @default 'dotted'
     */
    arrayKeysIndexStyle?: 'dotted' | 'braces-with-dot' | 'braces';
}

/**
 * Checks whether any of the {@link keys} are in the {@link map}
 * @param map The map to check
 * @param keys The keys to find in the map
 * @returns `true` if at least one of the {@link keys} is in the {@link map}, `false` otherwise.
 */
declare function hasAtLeastOneKeyInMap<T>(map: ReadonlyMap<T, any>, keys: readonly T[]): boolean;

/**
 * Wraps text in a markdown inline codeblock
 * @param expression The expression to be wrapped in the codeblock
 */
declare function inlineCodeBlock(input: string): string;

/**
 * Verify if the input is a class constructor.
 * @param input The function to verify
 */
declare function isClass(input: unknown): input is Ctor;

/**
 * Verify if the input is a function.
 * @param input The function to verify
 */
declare function isFunction(input: unknown): input is Function;

/**
 * Checks whether or not a value is `null` or `undefined`
 * @param value The value to check
 */
declare function isNullOrUndefined(value: unknown): value is Nullish;

/**
 * Checks whether or not a value is `null`, `undefined` or `''`, `[]`
 * @param value The value to check
 */
declare function isNullOrUndefinedOrEmpty(value: unknown): value is Nullish | '';

/**
 * Checks whether or not a value is `null`, `undefined` or `0`
 * @param value The value to check
 */
declare function isNullOrUndefinedOrZero(value: unknown): value is Nullish | 0;

/**
 * Verify if a number is a finite number.
 * @param input The number to verify
 */
declare function isNumber(input: unknown): input is number;

/**
 * Verify if the input is an object literal (or class).
 * @param input The object to verify
 * @param constructorType The type of the constructor of the object. Use this if you want a `class` of your choosing to pass the check as well.
 */
declare function isObject(input: unknown, constructorType?: ObjectConstructor): input is NonNullObject;
declare function isObject<T extends Constructor<unknown>>(input: unknown, constructorType: T): input is InstanceType<T>;

/**
 * Check whether a value is a primitive
 * @param input The input to check
 */
declare function isPrimitive(input: unknown): input is string | bigint | number | boolean;

interface Thenable {
    then: Function;
    catch: Function;
}
/**
 * Verify if an object is a promise.
 * @param input The promise to verify
 */
declare function isThenable(input: unknown): input is Thenable;

/**
 * Lazily creates a constant or load a module and caches it internally
 * @param cb The callback to lazily run
 * @returns The value returned by the callback, or the cached value if it was already initialised once.
 */
declare function lazy<T>(cb: () => T): () => T;

/**
 * Turn a dotted path into a json object.
 * @param path The dotted path
 * @param value The value
 * @param obj The object to edit
 */
declare function makeObject(path: string, value: unknown, obj?: Record<string, unknown>): Record<string, unknown>;

/**
 * Deep merges 2 objects. Properties from the second parameter are applied to the first.
 * @remark `overwrites` is also mutated!
 * @remark If the value of a key in `overwrites` is `undefined` then the value of that same key in `base` is used instead!
 * @remark This is essentially `{ ...base, ...overwrites }` but recursively
 * @param base Base object
 * @param overwrites Overwrites to apply
 * @example
 * ```typescript
 * const base = { a: 0, b: 1 };
 * const overwrites = {}; // will be { a: 0, b: 1 } after merge
 * mergeDefault(base, overwrites) // { a: 0, b: 1 }
 * ```
 * @example
 * ```typescript
 * const base = { a: 0, b: 1 };
 * const overwrites = { a: 2, i: 3 };
 * mergeDefault(base, overwrites) // { a: 2, i: 3, b: 1 };
 * ```
 * @example
 * ```typescript
 * const base = { a: 0, b: 1 };
 * const overwrites = { a: null };
 * mergeDefault(base, overwrites) // { a: null, b: 1 };
 * ```
 * @example
 * ```typescript
 * const base = { a: 0, b: 1 };
 * const overwrites = { a: undefined };
 * mergeDefault(base, overwrites) // { a: 0, b: 1 };
 * ```
 * @example
 * ```typescript
 * const base = { a: null };
 * const overwrites = { a: { b: 5 } };
 * mergeDefault(base, overwrites) // { a: { b: 5 } };
 * ```
 */
declare function mergeDefault<A extends NonNullObject, B extends Partial<A>>(base: A, overwrites?: B): DeepRequired<A & B>;

/**
 * Merges two objects
 * @param objTarget The object to be merged
 * @param objSource The object to merge
 */
declare function mergeObjects<A extends object, B extends object>(objTarget: A, objSource: Readonly<B>): A & B;

declare function noop(): void;

/**
 * Convert an object to a tuple
 * @param obj The object to convert
 * @param prefix The prefix for the key
 */
declare function objectToTuples<T>(obj: AnyObject<T>, prefix?: string): [keyof T, T[keyof T]][];

/**
 * Parses an URL, returns null if invalid.
 * @param url The url to parse
 */
declare function parseURL(url: string): URL | null;

/**
 * Partitions `array` into a tuple of two arrays,
 * where one array contains all elements that satisfies `predicate`,
 * and the other contains all elements that do not satisfy `predicate`.
 * @param array The array to partition. This array is not mutated.
 * @param predicate The predicate function to determine in which partition the item should be placed.
 * The function should return true for items that should be placed in the first partition, and false for those that should be placed in the second partition.
 * @returns A tuple of two arrays.
 */
declare function partition<T>(array: T[], predicate: (value: T, index: number) => boolean): T[][];

/**
 * Get an array of numbers with the selected range
 * @param min The minimum value
 * @param max The maximum value
 * @param step The step value
 */
declare function range(min: number, max: number, step: number): number[];

/**
 * Cleans a string from regex injection
 * @param str The string to clean
 */
declare function regExpEsc(str: string): string;

/**
 * Properly rounds up or down a number.
 * Also supports strings using an exponent to indicate large or small numbers.
 * @param num The number to round off
 * @param scale The amount of decimals to retain
 */
declare function roundNumber(num: number | string, scale?: number): number;

/**
 * Split a string by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @param char The character to split with
 * @copyright 2019 Antonio Román
 * @license Apache-2.0
 */
declare function splitText(str: string, length: number, char?: string): string;

/**
 * Converts a string to Title Case
 *
 * @description This is designed to also ensure common Discord PascalCased strings
 * are put in their TitleCase {@link baseVariants}.
 *
 * You can also provide your own variants to merge with the {@link baseVariants} for
 * your own functionality use.
 *
 * @param str The string to title case
 * @param options The options to use when converting the string
 */
declare function toTitleCase(str: string, options?: ToTitleCaseOptions): string;
/**
 * The options to use when converting a string to title case
 */
interface ToTitleCaseOptions {
    /**
     * The optional additional variants to use when converting the string
     */
    additionalVariants?: Record<string, string>;
    /**
     * Whether to convert the string to title case in a case sensitive manner.
     */
    caseSensitive?: boolean;
}

/**
 * Try parse a stringified JSON string.
 * @param value The value to parse
 */
declare function tryParse(value: string): object | string;

export { AbstractConstructor, AbstractCtor, AnyObject, ArgumentTypes, Arr, ArrayElementType, Awaitable, Builtin, Constructor, Ctor, DebounceSettings, DebouncedFunc, DeepPartial, DeepRequired, FirstArgument, GetDeepObjectKeysOptions, Mutable, NonNullObject, NonNullableProperties, Nullish, PartialRequired, PickByValue, Primitive, RequiredExcept, SecondArgument, StrictRequired, Thenable, ToTitleCaseOptions, arrayStrictEquals, cast, chunk, classExtends, codeBlock, cutText, debounce, deepClone, filterNullAndUndefined, filterNullAndUndefinedAndEmpty, filterNullAndUndefinedAndZero, filterNullAndUndefined as filterNullish, filterNullAndUndefinedAndEmpty as filterNullishOrEmpty, filterNullAndUndefinedAndZero as filterNullishOrZero, getDeepObjectKeys, hasAtLeastOneKeyInMap, inlineCodeBlock, isClass, isFunction, isNullOrUndefined, isNullOrUndefinedOrEmpty, isNullOrUndefinedOrZero, isNullOrUndefined as isNullish, isNullOrUndefinedOrEmpty as isNullishOrEmpty, isNullOrUndefinedOrZero as isNullishOrZero, isNumber, isObject, isPrimitive, isThenable, lazy, makeObject, mergeDefault, mergeObjects, noop, objectToTuples, parseURL, partition, range, regExpEsc, roundNumber, splitText, toTitleCase, tryParse };
