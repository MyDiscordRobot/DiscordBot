"use strict";
var SapphireCron = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Cron: () => Cron,
    Time: () => Time,
    allowedNum: () => allowedNum,
    cronTokens: () => cronTokens,
    partRegex: () => partRegex,
    predefined: () => predefined,
    tokensRegex: () => tokensRegex,
    wildcardRegex: () => wildcardRegex
  });

  // src/lib/constants.ts
  var Time = /* @__PURE__ */ ((Time2) => {
    Time2[Time2["Millisecond"] = 1] = "Millisecond";
    Time2[Time2["Second"] = 1e3] = "Second";
    Time2[Time2["Minute"] = 6e4] = "Minute";
    Time2[Time2["Hour"] = 36e5] = "Hour";
    Time2[Time2["Day"] = 864e5] = "Day";
    Time2[Time2["Month"] = 2628e6] = "Month";
    Time2[Time2["Year"] = 31536e6] = "Year";
    return Time2;
  })(Time || {});
  var partRegex = /^(?:(\*)|(\d+)(?:-(\d+))?)(?:\/(\d+))?$/;
  var wildcardRegex = /\bh\b|\B\?\B/g;
  var allowedNum = [
    [0, 59],
    [0, 23],
    [1, 31],
    [1, 12],
    [0, 6]
  ];
  var predefined = {
    "@annually": "0 0 1 1 *",
    "@yearly": "0 0 1 1 *",
    "@monthly": "0 0 1 * *",
    "@weekly": "0 0 * * 0",
    "@daily": "0 0 * * *",
    "@hourly": "0 * * * *"
  };
  var cronTokens = {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12,
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  };
  var tokensRegex = new RegExp(Object.keys(cronTokens).join("|"), "g");

  // ../utilities/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
  function arrayStrictEquals(arr1, arr2) {
    if (arr1 === arr2)
      return true;
    if (arr1.length !== arr2.length)
      return false;
    for (let i = 0; i < arr1.length; i++) {
      if (arr1[i] !== arr2[i] || typeof arr1[i] !== typeof arr2[i])
        return false;
    }
    return true;
  }
  __name(arrayStrictEquals, "arrayStrictEquals");
  __name2(arrayStrictEquals, "arrayStrictEquals");
  function cast(value) {
    return value;
  }
  __name(cast, "cast");
  __name2(cast, "cast");
  function chunk(array, chunkSize) {
    if (!Array.isArray(array))
      throw new TypeError("entries must be an array.");
    if (!Number.isInteger(chunkSize))
      throw new TypeError("chunkSize must be an integer.");
    if (chunkSize < 1)
      throw new RangeError("chunkSize must be 1 or greater.");
    const clone = array.slice();
    const chunks = [];
    while (clone.length)
      chunks.push(clone.splice(0, chunkSize));
    return chunks;
  }
  __name(chunk, "chunk");
  __name2(chunk, "chunk");
  function classExtends(value, base) {
    let ctor = value;
    while (ctor !== null) {
      if (ctor === base)
        return true;
      ctor = Object.getPrototypeOf(ctor);
    }
    return false;
  }
  __name(classExtends, "classExtends");
  __name2(classExtends, "classExtends");
  var zws = String.fromCharCode(8203);
  function codeBlock(language, expression) {
    if (typeof expression === "string") {
      if (expression.length === 0)
        return `\`\`\`${zws}\`\`\``;
      return `\`\`\`${language}
${expression.replace(/```/, `\`${zws}\`\``).replace(/`$/g, `\`${zws}`)}\`\`\``;
    }
    return `\`\`\`${language}
${expression || zws}\`\`\``;
  }
  __name(codeBlock, "codeBlock");
  __name2(codeBlock, "codeBlock");
  function splitText(str, length, char = " ") {
    const x = str.substring(0, length).lastIndexOf(char);
    const pos = x === -1 ? length : x;
    return str.substring(0, pos);
  }
  __name(splitText, "splitText");
  __name2(splitText, "splitText");
  function cutText(str, length) {
    if (str.length < length)
      return str;
    const cut = splitText(str, length - 3);
    if (cut.length < length - 3)
      return `${cut}...`;
    return `${cut.slice(0, length - 3)}...`;
  }
  __name(cutText, "cutText");
  __name2(cutText, "cutText");
  function debounce(func, options = {}) {
    var _a;
    let lastArgs;
    let result;
    let timerId;
    let lastCallTime;
    let lastInvokeTime = 0;
    const wait = (_a = options.wait) != null ? _a : 0;
    const maxWait = typeof options.maxWait === "number" ? Math.max(options.maxWait, wait) : null;
    function invokeFunc(time) {
      const args = lastArgs;
      lastArgs = void 0;
      lastInvokeTime = time;
      result = func(...args);
      return result;
    }
    __name(invokeFunc, "invokeFunc");
    __name2(invokeFunc, "invokeFunc");
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return result;
    }
    __name(leadingEdge, "leadingEdge");
    __name2(leadingEdge, "leadingEdge");
    function remainingWait(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      const result2 = wait - timeSinceLastCall;
      return maxWait === null ? result2 : Math.min(result2, maxWait - timeSinceLastInvoke);
    }
    __name(remainingWait, "remainingWait");
    __name2(remainingWait, "remainingWait");
    function shouldInvoke(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== null && timeSinceLastInvoke >= maxWait;
    }
    __name(shouldInvoke, "shouldInvoke");
    __name2(shouldInvoke, "shouldInvoke");
    function timerExpired() {
      const time = Date.now();
      if (shouldInvoke(time)) {
        trailingEdge(time);
        return;
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    __name(timerExpired, "timerExpired");
    __name2(timerExpired, "timerExpired");
    function trailingEdge(time) {
      timerId = void 0;
      return invokeFunc(time);
    }
    __name(trailingEdge, "trailingEdge");
    __name2(trailingEdge, "trailingEdge");
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = void 0;
      lastCallTime = void 0;
      timerId = void 0;
    }
    __name(cancel, "cancel");
    __name2(cancel, "cancel");
    function flush() {
      return timerId === void 0 ? result : trailingEdge(Date.now());
    }
    __name(flush, "flush");
    __name2(flush, "flush");
    function debounced(...args) {
      const time = Date.now();
      const isInvoking = shouldInvoke(time);
      lastArgs = args;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxWait !== null) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    __name(debounced, "debounced");
    __name2(debounced, "debounced");
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  __name(debounce, "debounce");
  __name2(debounce, "debounce");
  var primitiveTypes = ["string", "bigint", "number", "boolean"];
  function isPrimitive(input) {
    return primitiveTypes.includes(typeof input);
  }
  __name(isPrimitive, "isPrimitive");
  __name2(isPrimitive, "isPrimitive");
  function deepClone(source) {
    if (source === null || isPrimitive(source)) {
      return source;
    }
    if (source instanceof Date) {
      const output = new source.constructor(source);
      return output;
    }
    if (Array.isArray(source)) {
      const output = new source.constructor(source.length);
      for (let i = 0; i < source.length; i++) {
        output[i] = deepClone(source[i]);
      }
      return output;
    }
    if (source instanceof Map) {
      const output = new source.constructor();
      for (const [key, value] of source.entries()) {
        output.set(key, deepClone(value));
      }
      return output;
    }
    if (source instanceof Set) {
      const output = new source.constructor();
      for (const value of source.values()) {
        output.add(deepClone(value));
      }
      return output;
    }
    if (typeof source === "object") {
      const output = new source.constructor();
      for (const [key, value] of Object.entries(source)) {
        Object.defineProperty(output, key, {
          configurable: true,
          enumerable: true,
          value: deepClone(value),
          writable: true
        });
      }
      return output;
    }
    return source;
  }
  __name(deepClone, "deepClone");
  __name2(deepClone, "deepClone");
  function isNullOrUndefined(value) {
    return value === void 0 || value === null;
  }
  __name(isNullOrUndefined, "isNullOrUndefined");
  __name2(isNullOrUndefined, "isNullOrUndefined");
  function filterNullAndUndefined(value) {
    return !isNullOrUndefined(value);
  }
  __name(filterNullAndUndefined, "filterNullAndUndefined");
  __name2(filterNullAndUndefined, "filterNullAndUndefined");
  function isNullOrUndefinedOrEmpty(value) {
    return isNullOrUndefined(value) || value.length === 0;
  }
  __name(isNullOrUndefinedOrEmpty, "isNullOrUndefinedOrEmpty");
  __name2(isNullOrUndefinedOrEmpty, "isNullOrUndefinedOrEmpty");
  function filterNullAndUndefinedAndEmpty(value) {
    return !isNullOrUndefinedOrEmpty(value);
  }
  __name(filterNullAndUndefinedAndEmpty, "filterNullAndUndefinedAndEmpty");
  __name2(filterNullAndUndefinedAndEmpty, "filterNullAndUndefinedAndEmpty");
  function isNullOrUndefinedOrZero(value) {
    return value === 0 || isNullOrUndefined(value);
  }
  __name(isNullOrUndefinedOrZero, "isNullOrUndefinedOrZero");
  __name2(isNullOrUndefinedOrZero, "isNullOrUndefinedOrZero");
  function filterNullAndUndefinedAndZero(value) {
    return !isNullOrUndefinedOrZero(value);
  }
  __name(filterNullAndUndefinedAndZero, "filterNullAndUndefinedAndZero");
  __name2(filterNullAndUndefinedAndZero, "filterNullAndUndefinedAndZero");
  function getDeepObjectKeys(obj, options) {
    return [...getDeepObjectKeysGenerator(obj, options)];
  }
  __name(getDeepObjectKeys, "getDeepObjectKeys");
  __name2(getDeepObjectKeys, "getDeepObjectKeys");
  function* getDeepObjectKeysGenerator(obj, { arrayKeysIndexStyle = "dotted" } = { arrayKeysIndexStyle: "dotted" }) {
    if (Array.isArray(obj)) {
      for (const [index, value] of obj.entries()) {
        yield* getDeepArrayKeysRecursive(value, index, { arrayKeysIndexStyle });
      }
    } else {
      for (const [key, value] of Object.entries(obj)) {
        yield* getDeepObjectKeysRecursive(value, `${key}`, { arrayKeysIndexStyle });
      }
    }
  }
  __name(getDeepObjectKeysGenerator, "getDeepObjectKeysGenerator");
  __name2(getDeepObjectKeysGenerator, "getDeepObjectKeysGenerator");
  function* getDeepArrayKeysRecursive(value, index, { arrayKeysIndexStyle }) {
    const resolvedIndex = arrayKeysIndexStyle === "dotted" ? `${index}` : arrayKeysIndexStyle === "braces" ? `[${index}]` : `[${index}].`;
    yield* getDeepObjectKeysRecursive(value, resolvedIndex, { arrayKeysIndexStyle });
  }
  __name(getDeepArrayKeysRecursive, "getDeepArrayKeysRecursive");
  __name2(getDeepArrayKeysRecursive, "getDeepArrayKeysRecursive");
  function* getDeepObjectKeysRecursive(obj, prefix, { arrayKeysIndexStyle }) {
    if (typeof obj !== "object" || obj === null) {
      yield prefix;
      return;
    }
    if (Array.isArray(obj)) {
      for (const [index, value] of obj.entries()) {
        const resolvedPrefixedIndex = arrayKeysIndexStyle === "dotted" ? `${prefix}.${index}` : `${prefix}[${index}]`;
        yield* getDeepObjectKeysRecursive(value, resolvedPrefixedIndex, { arrayKeysIndexStyle });
      }
    } else {
      const objectEntries = Object.entries(obj);
      if (isNullOrUndefinedOrEmpty(objectEntries) && prefix) {
        yield prefix;
      } else {
        for (const [key, value] of objectEntries) {
          yield* getDeepObjectKeysRecursive(value, arrayKeysIndexStyle === "braces" ? `${prefix}${key}` : `${prefix}.${key}`, {
            arrayKeysIndexStyle
          });
        }
      }
    }
  }
  __name(getDeepObjectKeysRecursive, "getDeepObjectKeysRecursive");
  __name2(getDeepObjectKeysRecursive, "getDeepObjectKeysRecursive");
  function hasAtLeastOneKeyInMap(map, keys) {
    return keys.some((key) => map.has(key));
  }
  __name(hasAtLeastOneKeyInMap, "hasAtLeastOneKeyInMap");
  __name2(hasAtLeastOneKeyInMap, "hasAtLeastOneKeyInMap");
  var zws2 = String.fromCharCode(8203);
  function inlineCodeBlock(input) {
    return `\`${input.replace(/ /g, "\xA0").replace(/`/g, `\`${zws2}`)}\``;
  }
  __name(inlineCodeBlock, "inlineCodeBlock");
  __name2(inlineCodeBlock, "inlineCodeBlock");
  function isClass(input) {
    return typeof input === "function" && typeof input.prototype === "object";
  }
  __name(isClass, "isClass");
  __name2(isClass, "isClass");
  function isFunction(input) {
    return typeof input === "function";
  }
  __name(isFunction, "isFunction");
  __name2(isFunction, "isFunction");
  function isNumber(input) {
    if (typeof input === "string")
      input = Number(input);
    return typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input);
  }
  __name(isNumber, "isNumber");
  __name2(isNumber, "isNumber");
  function isObject(input, constructorType) {
    return typeof input === "object" && input ? input.constructor === (constructorType != null ? constructorType : Object) : false;
  }
  __name(isObject, "isObject");
  __name2(isObject, "isObject");
  function hasThen(input) {
    return Reflect.has(input, "then") && isFunction(input.then);
  }
  __name(hasThen, "hasThen");
  __name2(hasThen, "hasThen");
  function hasCatch(input) {
    return Reflect.has(input, "catch") && isFunction(input.catch);
  }
  __name(hasCatch, "hasCatch");
  __name2(hasCatch, "hasCatch");
  function isThenable(input) {
    if (typeof input !== "object" || input === null)
      return false;
    return input instanceof Promise || input !== Promise.prototype && hasThen(input) && hasCatch(input);
  }
  __name(isThenable, "isThenable");
  __name2(isThenable, "isThenable");
  function lazy(cb) {
    let defaultValue;
    return () => defaultValue != null ? defaultValue : defaultValue = cb();
  }
  __name(lazy, "lazy");
  __name2(lazy, "lazy");
  function makeObject(path, value, obj = {}) {
    if (path.includes(".")) {
      const route = path.split(".");
      const lastKey = route.pop();
      let reference = obj;
      for (const key of route) {
        if (!reference[key])
          reference[key] = {};
        reference = reference[key];
      }
      reference[lastKey] = value;
    } else {
      obj[path] = value;
    }
    return obj;
  }
  __name(makeObject, "makeObject");
  __name2(makeObject, "makeObject");
  function mergeDefault(base, overwrites) {
    if (!overwrites)
      return deepClone(base);
    for (const [baseKey, baseValue] of Object.entries(base)) {
      const overwritesValueAtBaseKey = Reflect.get(overwrites, baseKey);
      if (typeof overwritesValueAtBaseKey === "undefined") {
        Reflect.set(overwrites, baseKey, deepClone(baseValue));
      } else if (isObject(overwritesValueAtBaseKey)) {
        Reflect.set(overwrites, baseKey, mergeDefault(baseValue != null ? baseValue : {}, overwritesValueAtBaseKey));
      }
    }
    return overwrites;
  }
  __name(mergeDefault, "mergeDefault");
  __name2(mergeDefault, "mergeDefault");
  function mergeObjects(objTarget, objSource) {
    for (const [key, value] of Object.entries(objSource)) {
      const targetValue = Reflect.get(objTarget, key);
      if (isObject(value)) {
        Reflect.set(objTarget, key, isObject(targetValue) ? mergeObjects(targetValue, value) : value);
      } else if (!isObject(targetValue)) {
        Reflect.set(objTarget, key, value);
      }
    }
    return objTarget;
  }
  __name(mergeObjects, "mergeObjects");
  __name2(mergeObjects, "mergeObjects");
  function noop() {
  }
  __name(noop, "noop");
  __name2(noop, "noop");
  function objectToTuples(obj, prefix = "") {
    const entries = [];
    for (const [key, value] of Object.entries(obj)) {
      if (isObject(value)) {
        entries.push(...objectToTuples(value, `${prefix}${key}.`));
      } else {
        entries.push([`${prefix}${key}`, value]);
      }
    }
    return entries;
  }
  __name(objectToTuples, "objectToTuples");
  __name2(objectToTuples, "objectToTuples");
  function parseURL(url) {
    try {
      return new URL(url);
    } catch {
      return null;
    }
  }
  __name(parseURL, "parseURL");
  __name2(parseURL, "parseURL");
  function partition(array, predicate) {
    if (!Array.isArray(array))
      throw new TypeError("entries must be an array.");
    if (!isFunction(predicate))
      throw new TypeError("predicate must be an function that returns a boolean value.");
    const partitionOne = [];
    const partitionTwo = [];
    for (let i = 0; i < array.length; i++) {
      if (predicate(array[i], i)) {
        partitionOne.push(array[i]);
      } else {
        partitionTwo.push(array[i]);
      }
    }
    return [partitionOne, partitionTwo];
  }
  __name(partition, "partition");
  __name2(partition, "partition");
  function range(min, max, step) {
    return new Array(Math.floor((max - min) / step) + 1).fill(0).map((_val, i) => min + i * step);
  }
  __name(range, "range");
  __name2(range, "range");
  var REGEXPESC = /[-/\\^$*+?.()|[\]{}]/g;
  function regExpEsc(str) {
    return str.replace(REGEXPESC, "\\$&");
  }
  __name(regExpEsc, "regExpEsc");
  __name2(regExpEsc, "regExpEsc");
  function roundNumber(num, scale = 0) {
    if (!num.toString().includes("e")) {
      return Number(`${Math.round(Number(`${num}e+${scale}`))}e-${scale}`);
    }
    const arr = `${num}`.split("e");
    let sig = "";
    if (Number(arr[1]) + scale > 0) {
      sig = "+";
    }
    return Number(`${Math.round(Number(`${Number(arr[0])}e${sig}${Number(arr[1]) + scale}`))}e-${scale}`);
  }
  __name(roundNumber, "roundNumber");
  __name2(roundNumber, "roundNumber");
  var TO_TITLE_CASE = /[A-Za-zÀ-ÖØ-öø-ÿ]\S*/g;
  var baseVariants = {
    textchannel: "TextChannel",
    voicechannel: "VoiceChannel",
    categorychannel: "CategoryChannel",
    guildmember: "GuildMember"
  };
  function toTitleCase(str, options = {}) {
    const { additionalVariants = {}, caseSensitive } = options;
    const titleCaseVariants = {
      ...baseVariants,
      ...caseSensitive ? additionalVariants : Object.entries(additionalVariants).reduce(
        (variants, [key, variant]) => ({ ...variants, [key.toLowerCase()]: variant }),
        {}
      )
    };
    return str.replace(
      TO_TITLE_CASE,
      (txt) => {
        var _a;
        return (_a = titleCaseVariants[caseSensitive ? txt : txt.toLowerCase()]) != null ? _a : txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();
      }
    );
  }
  __name(toTitleCase, "toTitleCase");
  __name2(toTitleCase, "toTitleCase");
  function tryParse(value) {
    try {
      return JSON.parse(value);
    } catch (err) {
      return value;
    }
  }
  __name(tryParse, "tryParse");
  __name2(tryParse, "tryParse");

  // src/lib/Cron.ts
  var Cron = class {
    constructor(cron) {
      __publicField(this, "cron");
      __publicField(this, "normalized");
      __publicField(this, "minutes");
      __publicField(this, "hours");
      __publicField(this, "days");
      __publicField(this, "months");
      __publicField(this, "dows");
      this.cron = cron.toLowerCase();
      this.normalized = Cron.normalize(this.cron);
      [this.minutes, this.hours, this.days, this.months, this.dows] = Cron.parseString(this.normalized);
    }
    next(outset = new Date(), origin = true) {
      if (!this.days.includes(outset.getUTCDate()) || !this.months.includes(outset.getUTCMonth() + 1) || !this.dows.includes(outset.getUTCDay())) {
        return this.next(new Date(outset.getTime() + 864e5 /* Day */), false);
      }
      if (!origin)
        return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), this.hours[0], this.minutes[0]));
      const now = new Date(outset.getTime() + 6e4);
      for (const hour of this.hours) {
        if (hour < now.getUTCHours())
          continue;
        for (const minute of this.minutes) {
          if (hour === now.getUTCHours() && minute < now.getUTCMinutes())
            continue;
          return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), hour, minute));
        }
      }
      return this.next(new Date(outset.getTime() + 864e5 /* Day */), false);
    }
    static normalize(cron) {
      if (Reflect.has(predefined, cron))
        return Reflect.get(predefined, cron);
      const now = new Date();
      cron = cron.split(" ").map(
        (val, i) => val.replace(wildcardRegex, (match) => {
          if (match === "h")
            return (Math.floor(Math.random() * allowedNum[i][1]) + allowedNum[i][0]).toString();
          if (match === "?") {
            switch (i) {
              case 0:
                return now.getUTCMinutes().toString();
              case 1:
                return now.getUTCHours().toString();
              case 2:
                return now.getUTCDate().toString();
              case 3:
                return now.getUTCMonth().toString();
              case 4:
                return now.getUTCDay().toString();
            }
          }
          return match;
        })
      ).join(" ");
      return cron.replace(tokensRegex, (match) => String(Reflect.get(cronTokens, match)));
    }
    static parseString(cron) {
      const parts = cron.split(" ");
      if (parts.length !== 5)
        throw new Error("Invalid Cron Provided");
      return parts.map((part, i) => Cron.parsePart(part, i));
    }
    static parsePart(cronPart, id) {
      if (cronPart.includes(",")) {
        const res = [];
        for (const part of cronPart.split(","))
          res.push(...Cron.parsePart(part, id));
        return [...new Set(res)].sort((a, b) => a - b);
      }
      const [, wild, minStr, maxStr, step] = partRegex.exec(cronPart);
      let [min, max] = [parseInt(minStr, 10), parseInt(maxStr, 10)];
      if (wild)
        [min, max] = allowedNum[id];
      else if (!max && !step)
        return [min];
      [min, max] = [min, max || allowedNum[id][1]].sort((a, b) => a - b);
      return range(min, max, parseInt(step, 10) || 1);
    }
  };
  __name(Cron, "Cron");
  return __toCommonJS(src_exports);
})();
/**
 * Split a string by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @param char The character to split with
 * @copyright 2019 Aura Román
 * @license Apache-2.0
 */
/**
 * Split a text by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @copyright 2019 Aura Román
 * @license Apache-2.0
 */
//# sourceMappingURL=index.global.js.map