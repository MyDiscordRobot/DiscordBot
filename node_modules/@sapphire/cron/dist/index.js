"use strict";
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Cron: () => Cron,
  Time: () => Time,
  allowedNum: () => allowedNum,
  cronTokens: () => cronTokens,
  partRegex: () => partRegex,
  predefined: () => predefined,
  tokensRegex: () => tokensRegex,
  wildcardRegex: () => wildcardRegex
});
module.exports = __toCommonJS(src_exports);

// src/lib/constants.ts
var Time = /* @__PURE__ */ ((Time2) => {
  Time2[Time2["Millisecond"] = 1] = "Millisecond";
  Time2[Time2["Second"] = 1e3] = "Second";
  Time2[Time2["Minute"] = 6e4] = "Minute";
  Time2[Time2["Hour"] = 36e5] = "Hour";
  Time2[Time2["Day"] = 864e5] = "Day";
  Time2[Time2["Month"] = 2628e6] = "Month";
  Time2[Time2["Year"] = 31536e6] = "Year";
  return Time2;
})(Time || {});
var partRegex = /^(?:(\*)|(\d+)(?:-(\d+))?)(?:\/(\d+))?$/;
var wildcardRegex = /\bh\b|\B\?\B/g;
var allowedNum = [
  [0, 59],
  [0, 23],
  [1, 31],
  [1, 12],
  [0, 6]
];
var predefined = {
  "@annually": "0 0 1 1 *",
  "@yearly": "0 0 1 1 *",
  "@monthly": "0 0 1 * *",
  "@weekly": "0 0 * * 0",
  "@daily": "0 0 * * *",
  "@hourly": "0 * * * *"
};
var cronTokens = {
  jan: 1,
  feb: 2,
  mar: 3,
  apr: 4,
  may: 5,
  jun: 6,
  jul: 7,
  aug: 8,
  sep: 9,
  oct: 10,
  nov: 11,
  dec: 12,
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6
};
var tokensRegex = new RegExp(Object.keys(cronTokens).join("|"), "g");

// src/lib/Cron.ts
var import_utilities = require("@sapphire/utilities");
var Cron = class {
  constructor(cron) {
    __publicField(this, "cron");
    __publicField(this, "normalized");
    __publicField(this, "minutes");
    __publicField(this, "hours");
    __publicField(this, "days");
    __publicField(this, "months");
    __publicField(this, "dows");
    this.cron = cron.toLowerCase();
    this.normalized = Cron.normalize(this.cron);
    [this.minutes, this.hours, this.days, this.months, this.dows] = Cron.parseString(this.normalized);
  }
  next(outset = new Date(), origin = true) {
    if (!this.days.includes(outset.getUTCDate()) || !this.months.includes(outset.getUTCMonth() + 1) || !this.dows.includes(outset.getUTCDay())) {
      return this.next(new Date(outset.getTime() + 864e5 /* Day */), false);
    }
    if (!origin)
      return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), this.hours[0], this.minutes[0]));
    const now = new Date(outset.getTime() + 6e4);
    for (const hour of this.hours) {
      if (hour < now.getUTCHours())
        continue;
      for (const minute of this.minutes) {
        if (hour === now.getUTCHours() && minute < now.getUTCMinutes())
          continue;
        return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), hour, minute));
      }
    }
    return this.next(new Date(outset.getTime() + 864e5 /* Day */), false);
  }
  static normalize(cron) {
    if (Reflect.has(predefined, cron))
      return Reflect.get(predefined, cron);
    const now = new Date();
    cron = cron.split(" ").map(
      (val, i) => val.replace(wildcardRegex, (match) => {
        if (match === "h")
          return (Math.floor(Math.random() * allowedNum[i][1]) + allowedNum[i][0]).toString();
        if (match === "?") {
          switch (i) {
            case 0:
              return now.getUTCMinutes().toString();
            case 1:
              return now.getUTCHours().toString();
            case 2:
              return now.getUTCDate().toString();
            case 3:
              return now.getUTCMonth().toString();
            case 4:
              return now.getUTCDay().toString();
          }
        }
        return match;
      })
    ).join(" ");
    return cron.replace(tokensRegex, (match) => String(Reflect.get(cronTokens, match)));
  }
  static parseString(cron) {
    const parts = cron.split(" ");
    if (parts.length !== 5)
      throw new Error("Invalid Cron Provided");
    return parts.map((part, i) => Cron.parsePart(part, i));
  }
  static parsePart(cronPart, id) {
    if (cronPart.includes(",")) {
      const res = [];
      for (const part of cronPart.split(","))
        res.push(...Cron.parsePart(part, id));
      return [...new Set(res)].sort((a, b) => a - b);
    }
    const [, wild, minStr, maxStr, step] = partRegex.exec(cronPart);
    let [min, max] = [parseInt(minStr, 10), parseInt(maxStr, 10)];
    if (wild)
      [min, max] = allowedNum[id];
    else if (!max && !step)
      return [min];
    [min, max] = [min, max || allowedNum[id][1]].sort((a, b) => a - b);
    return (0, import_utilities.range)(min, max, parseInt(step, 10) || 1);
  }
};
__name(Cron, "Cron");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Cron,
  Time,
  allowedNum,
  cronTokens,
  partRegex,
  predefined,
  tokensRegex,
  wildcardRegex
});
//# sourceMappingURL=index.js.map