{"version":3,"sources":["../src/lib/constants.ts","../src/lib/Cron.ts"],"sourcesContent":["export enum Time {\n\tMillisecond = 1,\n\tSecond = 1000,\n\tMinute = 1000 * 60,\n\tHour = 1000 * 60 * 60,\n\tDay = 1000 * 60 * 60 * 24,\n\tMonth = 1000 * 60 * 60 * 24 * (365 / 12),\n\tYear = 1000 * 60 * 60 * 24 * 365\n}\n\nexport const partRegex = /^(?:(\\*)|(\\d+)(?:-(\\d+))?)(?:\\/(\\d+))?$/;\n\nexport const wildcardRegex = /\\bh\\b|\\B\\?\\B/g;\n\nexport const allowedNum = [\n\t[0, 59],\n\t[0, 23],\n\t[1, 31],\n\t[1, 12],\n\t[0, 6]\n];\n\nexport const predefined = {\n\t'@annually': '0 0 1 1 *',\n\t'@yearly': '0 0 1 1 *',\n\t'@monthly': '0 0 1 * *',\n\t'@weekly': '0 0 * * 0',\n\t'@daily': '0 0 * * *',\n\t'@hourly': '0 * * * *'\n} as const;\n\nexport const cronTokens = {\n\tjan: 1,\n\tfeb: 2,\n\tmar: 3,\n\tapr: 4,\n\tmay: 5,\n\tjun: 6,\n\tjul: 7,\n\taug: 8,\n\tsep: 9,\n\toct: 10,\n\tnov: 11,\n\tdec: 12,\n\tsun: 0,\n\tmon: 1,\n\ttue: 2,\n\twed: 3,\n\tthu: 4,\n\tfri: 5,\n\tsat: 6\n} as const;\n\nexport const tokensRegex = new RegExp(Object.keys(cronTokens).join('|'), 'g');\n","/* eslint-disable @typescript-eslint/restrict-plus-operands */\nimport { range } from '@sapphire/utilities';\nimport { allowedNum, cronTokens, partRegex, predefined, Time, tokensRegex, wildcardRegex } from './constants';\n\n/**\n * Handles Cron strings and generates dates based on the cron string provided.\n * @see https://en.wikipedia.org/wiki/Cron\n */\nexport class Cron {\n\tpublic cron: string;\n\tpublic normalized: string;\n\tpublic minutes: number[];\n\tpublic hours: number[];\n\tpublic days: number[];\n\tpublic months: number[];\n\tpublic dows: number[];\n\n\t/**\n\t * @param cron The cron pattern to use\n\t */\n\tpublic constructor(cron: string) {\n\t\tthis.cron = cron.toLowerCase();\n\t\tthis.normalized = Cron.normalize(this.cron);\n\t\t[this.minutes, this.hours, this.days, this.months, this.dows] = Cron.parseString(this.normalized);\n\t}\n\n\t/**\n\t * Get the next date that matches with the current pattern\n\t * @param outset The Date instance to compare with\n\t * @param origin Whether this next call is origin\n\t */\n\tpublic next(outset: Date = new Date(), origin = true): Date {\n\t\tif (!this.days.includes(outset.getUTCDate()) || !this.months.includes(outset.getUTCMonth() + 1) || !this.dows.includes(outset.getUTCDay())) {\n\t\t\treturn this.next(new Date(outset.getTime() + Time.Day), false);\n\t\t}\n\t\tif (!origin) return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), this.hours[0], this.minutes[0]));\n\n\t\tconst now = new Date(outset.getTime() + 60000);\n\n\t\tfor (const hour of this.hours) {\n\t\t\tif (hour < now.getUTCHours()) continue;\n\t\t\tfor (const minute of this.minutes) {\n\t\t\t\tif (hour === now.getUTCHours() && minute < now.getUTCMinutes()) continue;\n\t\t\t\treturn new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), hour, minute));\n\t\t\t}\n\t\t}\n\n\t\treturn this.next(new Date(outset.getTime() + Time.Day), false);\n\t}\n\n\t/**\n\t * Normalize the pattern\n\t * @param cron The pattern to normalize\n\t */\n\tprivate static normalize(cron: string): string {\n\t\tif (Reflect.has(predefined, cron)) return Reflect.get(predefined, cron);\n\t\tconst now = new Date();\n\t\tcron = cron\n\t\t\t.split(' ')\n\t\t\t.map((val, i) =>\n\t\t\t\tval.replace(wildcardRegex, (match) => {\n\t\t\t\t\tif (match === 'h') return (Math.floor(Math.random() * allowedNum[i][1]) + allowedNum[i][0]).toString();\n\n\t\t\t\t\tif (match === '?') {\n\t\t\t\t\t\tswitch (i) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\treturn now.getUTCMinutes().toString();\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\treturn now.getUTCHours().toString();\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\treturn now.getUTCDate().toString();\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\treturn now.getUTCMonth().toString();\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\treturn now.getUTCDay().toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match;\n\t\t\t\t})\n\t\t\t)\n\t\t\t.join(' ');\n\t\treturn cron.replace(tokensRegex, (match) => String(Reflect.get(cronTokens, match)));\n\t}\n\n\t/**\n\t * Parse the pattern\n\t * @param cron The pattern to parse\n\t */\n\tprivate static parseString(cron: string): Array<number[]> {\n\t\tconst parts = cron.split(' ');\n\t\tif (parts.length !== 5) throw new Error('Invalid Cron Provided');\n\t\treturn parts.map((part, i) => Cron.parsePart(part, i));\n\t}\n\n\t/**\n\t * Parse the current part\n\t * @param cronPart The part of the pattern to parse\n\t * @param id The id that identifies the current part\n\t */\n\tprivate static parsePart(cronPart: string, id: number): number[] {\n\t\tif (cronPart.includes(',')) {\n\t\t\tconst res: number[] = [];\n\t\t\tfor (const part of cronPart.split(',')) res.push(...Cron.parsePart(part, id));\n\t\t\treturn [...new Set(res)].sort((a, b) => a - b);\n\t\t}\n\n\t\t// eslint-disable-next-line prefer-const\n\t\tconst [, wild, minStr, maxStr, step] = partRegex.exec(cronPart)!;\n\t\tlet [min, max] = [parseInt(minStr, 10), parseInt(maxStr, 10)];\n\n\t\t// If '*', set min and max as the minimum and maximum allowed numbers:\n\t\tif (wild) [min, max] = allowedNum[id];\n\t\t// Else if a number was given, but not a maximum nor a step, return it\n\t\t// as only allowed value:\n\t\telse if (!max && !step) return [min];\n\n\t\t// Set min and max as the given numbers, defaulting max to the maximum\n\t\t// allowed, so min is never bigger than max:\n\t\t// This makes min and max be, in the following cases (considering minutes):\n\t\t// -> 1-2 | 1..2\n\t\t// -> 2-1 | 1..2\n\t\t// -> 1/7 | 1, 8, 15, 22, 29, 36, 43, 50, 57\n\t\t[min, max] = [min, max || allowedNum[id][1]].sort((a, b) => a - b);\n\n\t\t// Generate a range\n\t\treturn range(min, max, parseInt(step, 10) || 1);\n\t}\n}\n"],"mappings":"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","names":["Time"]}